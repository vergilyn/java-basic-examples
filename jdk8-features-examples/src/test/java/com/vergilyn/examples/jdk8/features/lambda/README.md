## lambda expression
see:
- http://www.runoob.com/java/java8-lambda-expressions.html

### lambda语法
```
(parameters) -> expression
或
(parameters) ->{ statements; }
```
lambda表达式的重要特征:
- **可选类型声明：** 不需要声明参数类型，编译器可以统一识别参数值。
- **可选的参数圆括号：** 一个参数无需定义圆括号，但多个参数需要定义圆括号。
- **可选的大括号：** 如果主体包含了一个语句，就不需要使用大括号。
- **可选的返回关键字：** 如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。

### lambda的限制
see: https://www.cnblogs.com/invoker-/p/7709052.html#autoid-2-5-0

Java8中的lambda表达式,并不是完全闭包，lambda表达式对值封闭，不对变量封闭。
简单点来说就是局部变量在lambda表达式中如果要使用，必须是声明final类型或者是隐式的final，例如：
```
int num = 123;
Consumer<Integer> print = () -> System.out.println(num);
```
虽然num没有被声明为final，但从整体来看，他和final类型的变量的表现是一致的，可如果是这样的代码：
```
int num = 123;
num ++;
Consumer<Integer> print = () -> System.out.println(num);
```
则无法通过编译器，这就是对值封闭(也就是栈上的变量封闭)。  
如果上文中的num是实例变量或者是静态变量就没有这个限制。  
看到这里，自然而然就会有疑问为什么会这样？或者说为什么要这么设计。理由有很多，例如函数的不变性，线程安全等等等，这里我给一个简单的说明  

- 为什么局部变量会有限制而静态变量和全局变量就没有限制，因为局部变量是保存在栈上的，
而众所周知，栈上的变量都隐式的表现了它们仅限于它们所在的线程，而静态变量与实例变量是保存在静态区与堆中的，
而这两块区域是线程共享的，所以访问并没有问题。

- 现在我们假设如果lambda表达式可以局部变量的情况，实例变量存储在堆中，局部变量存储在栈上，
而lambda表达式是在另外一个线程中使用的，那么在访问局部变量的时候，因为线程不共享，因此lambda可能会在分配该变量的线程将这个变量收回之后，去访问该变量。
所以说，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了。

- 严格保证这种限制会让你的代码变得无比安全，如果你学习或了解过一些经典的函数式语言的话，就会知道不变性的重要性，这也是为什么stream流可以十分方便的改成并行流的重要原因之一。



